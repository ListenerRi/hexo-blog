---
title: 句不成章
comments: false
date: 2018-11-04 21:35:34
type:
---

> 在这里贴一些不成文章的短句，可能是偶现的灵感，可能是重要但不至于写得长篇大论的知识要点，也可能一些愿望和目标，还可能是吐槽或者抱怨，总之我也不确定会写点什么到这里 : )


## 2020-09-01 09:14
正向代理：隐藏了真实客户端，即代理了客户端
反向代理：隐藏了真实服务端，即代理了服务端

## 2020-08-25 14:33
感觉软件上的优化问题逃不出怪圈：还有问题？那就再加一层

## 2020-08-15 12:56
并行必然是需要多核的，一个处理器是无法并行的；但并发和处理器并没有什么必然联系，在一个处理器上面，我们的程序也可以是并发的。
> 举个简单的例子，华罗庚泡茶，必须有烧水、洗杯子、拿茶叶等步骤。现在我们想尽快做完这件事，也就是“一共要处理很多事情”，有很多方法可以实现并发，例如请多个人同时做，这就是并行。并行是实现并发的一种方式，但不是唯一的方式。我们一个人也可以实现并发，例如先烧水、然后不用等水烧开就去洗杯子，所以通过调整程序运行方式也可以实现并发。

## 2020-04-20 10:00
创建客户端容器：
```
docker create --name ss-local -p 1080:1080 -v /etc/ss.json:/etc/ss.json shadowsocks/shadowsocks-libev ss-local -c /etc/ss.json
```
当需要修改服务器时，修改主机 `/etc/ss.json` 的内容，也可创建多份配置文件，需要使用哪个配置文件时就创建其到主机 `/etc/ss.json` 的链接，之后执行：
```
docker restart ss-local
```
即为应用了修改，若不放心可以执行以下命令确认：
```
docker exec ss-local cat /etc/ss.json
```
服务端类似：
```
docker create --name ss-server -p 1234:1234 -v /etc/ss.json:/etc/ss.json shadowsocks/shadowsocks-libev ss-server -c /etc/ss.json
```
注意修改上述命令中的 `1234` 为配置文件 `/etc/ss.json` 中指定的服务器端口

## 2020-02-24 09:57
python 中 list 查找性能低且不能被 hash 因此能用 set 就不用 list 能用 tuple 也不用 list

## 2019-11-25 10:41
ClusterShell：一个在集群节点上并行运行命令的好工具

## 2019-03-31 00:08
又熬夜了 :(

## 2019-03-16 20:45
cpp 中使用关键字 auto 时如果要声明的变量是引用，不要忘了符号`&`

## 2019-03-16 20:32
cpp 中声明内联函数时切记不要忘了函数的返回值

## 2019-03-16 20:28
先找到问题的关键点，再找到解决问题的关键点，多个关键点结合才能正确地解决问题

***以下是以前积累在锤子闪念胶囊里的，一股脑全写出来了 : )***

------------------

## 2018-11-04 22:12
systemd 单元命令的参数中不能包含管道及重定向操作，需要将其封装到脚本中

## 2018-11-04 22:10
找到一个小矩形居中在一个大矩形时的坐标：
- 宽减宽除以 2，高减高除以 2
- 直接调用qt的函数：`QRect.moveCenter()`

## 2018-11-04 22:09
贫穷是一切苦难的源头

## 2018-11-04 22:07
壮志未酬，英雄迟暮(忘了是看哪个电影/电视剧而引发的感慨了)

## 2018-11-04 22:03
一个数 and 1 的结果就是取二进制的最末位，因为 1 的高位全是 0
一个数 or 1 的结果就是把二进制最末位强行变成 1，如果需要把二进制最末位变成 0，对这个数 or 1 之后再减 1 就可以了，其实际意义就是把这个数强行变成最接近的偶数
a << b 的值实际上就是 a 乘以 2 的 b 次方，因为在二进制数后添一个 0 就相当于该数乘以 2 
a >> b 表示二进制右移b位（去掉末 b 位），相当于 a 除以 2 的 b 次方（取整）。

## 2018-11-04 21:59
`mv src/* dest/` 命令不会移动 `src` 目录下以点开头的隐藏文件或目录，切记！

## 2018-11-04 21:54
Linux下所有图形应用的底层消息顺序都是按照下面的顺序来执行的：硬件产生事件 -> XServer 发送输入事件给图形库 -> 图形库(X Client) 包装输入事件传递给应用程序 -> 应用根据输入事件产生绘制命令 -> 图形库（X Client) 根据应用绘制命令产生绘制消息 -> XServer接受绘制消息 -> 绘制图形到屏幕上。

## 2018-11-04 21:47
一直被夸奖，不见得是好事
